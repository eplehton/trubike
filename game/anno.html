<html>
<head>
	<meta charset="UTF-8">
    <title>Videoclip annotator</title>

    <style>

    body {    
        background-color: #eeeeee;
    }

	#annobox {
		width: 100%;
		
	}
    #videobox {
        width: 70%;
    }
    
    #videoplayer {
        background-color: #aaaaaa;
        width: 100%;
        z-index: 1;
        /* float:left; */
    }

    #targetlist{
		
        background-color: #fff;
        width: 30%;
		float: right;
    }
    
    #videocontrols {
        /*clear: both;*/
    }

    .target_icon {
        width: 2em;
        height: 2em;
        border-radius: 50%;
        background-color: red;
        opacity: 0.5;
        z-index: 5;
        display: none;
        position: absolute;
    }



    </style>
    <script language="javascript" type="text/javascript" src="js/jquery-2.1.1.min.js"></script>
    <script type="text/javascript" src="js/peli.js"></script>
    <script type="text/javascript">
    
    var anno_targets = null;
    var anno_target_icons = []; // icon elements to display each target
    var current_anno_target = null;
    var update_target_icon_interval = 100;
    var update_target_icon_interval_id = null;
    var gui_append_mode;
	
    addTargetPoint = function(trg, x, y, t) {
        var loc = findInsertIndex(trg.t, t);
        trg.t.splice(loc, 0, t);
        trg.x.splice(loc, 0, x);
        trg.y.splice(loc, 0, y);
		 
		 
		//if (loc == trg.t.length) {
		//	appending_target_points_flag = True;
		//} else {
		//	appending_target_points_flag = False;
		//}
		
		// trg.end_t = trg.t[trg.t.length-1]; // 2014-10-04
		
		// added a point, so likely we are adding more and want to display the latest on the screen
		// this of course depends on the feature that all the anno targets will be ended when the video is seeked
		trg.end_t = Infinity;
		
    }
	
    delTargetEnd = function(trg) {
        console.log("delTargetEnd")
        trg.end_t = Infinity;
    }

    delTargetPoint = function(trg, loc) {
        console.log("delTargetPoint")
        trg.x.splice(loc, 1);
        trg.y.splice(loc, 1);
        trg.t.splice(loc, 1);
		
		trg.end_t = trg.t[trg.t.length-1]; // 2014-10-04
    }


    
    
    function delAnnoTarget(trg_ind) {
        if (current_anno_target == anno_targets[trg_ind]) {
            current_anno_target = null;
        }
        anno_targets.splice(trg_ind, 1);
		
		//// let's hide also the element representing it because it can be visible
        //anno_target_icons[trg_ind].style.display = "none";
		//anno_target_icons.splice(trg_ind, 1);
		
		saveAnnoTargets();
        
		updateTargetIcon();
        updateTargetList();
        //updateClipList();
    }
    
    
    function createTarget() {
        current_anno_target = new Target()
        anno_targets.push(current_anno_target);
    }
    
    function selectTarget(trg_ind) {
        console.log("selectTarget: " + trg_ind)
		current_anno_target = anno_targets[trg_ind];
		
    }

    /*function findFirstPosIndex(arr) {
        for (var i=0; i<arr.length; i++) {
            if (arr[i] > 0) { 
                return i;
            }
        }
        return null;
    }
    */
    function findLastNegIndex(arr) {
        //console.log("arr: " + arr)
        var lni = null;
        for (var i=0; i<arr.length; i++) {
            if (arr[i] < 0) { 
                lni = i;
            } else {
                break
            }
        }
        return lni;
    }
	

    /* function updateClipList() {
        var clip_selector = document.getElementById("annotated_clips");
        var all_targets = loadLocalTargets();
        
        var html = "";
        for (var cname in all_targets) {
            html += '<option value="'+ cname +'">'+ cname +'</option>';
        }
        console.log(html);
        clip_selector.innerHTML = html;
    }*/
    
    function loadVideo(filename) {
        var vplayer = document.getElementById("videoplayer");
		var clippath = document.getElementById("clippath").value;
 
        var src = clippath + filename;
		
		var n = src.indexOf('fakepath');
		if (n != -1){
			u = src.substring(n-3, n+9);
			src = src.replace(u, "");
		}
		
       vplayer.src = src;
       
       // load video specific targets
       var all_targets = loadLocalTargets();
       anno_targets = getSourceTargets(all_targets, vplayer.src);
        
       //setInterval( function(){ updateTargetList() }, 200)
    }


    function shotClicked(ev) {
        
        var vplayer = document.getElementById("videoplayer");
        var ctime = vplayer.currentTime;
        var src = vplayer.src;
        
        if (ctime > 0.0) {
            var relcoords = client2Rel(ev.clientX, ev.clientY)
            var x = relcoords[0]
            var y = relcoords[1]
            
            if (current_anno_target == null) {
                //console.log("create target")
                createTarget();
                 
            }
            addTargetPoint(current_anno_target, x, y, ctime)
            updateTargetList()
        }
        
        
    }

    
    function updateTargetIcon() {
       
        var vplayer = document.getElementById("videoplayer");
        var target_icon_tmpl = document.getElementById("target_icon_tmpl");
        var ctime = vplayer.currentTime;
   
        var src_trgs = anno_targets; // from memory, not from localStorage now... getSourceTargets(vplayer.src, targets);
        

        
        //console.log('src_trgs: ' + src_trgs)
        
	
		
		
        for (var i=0; i < src_trgs.length; i++) {
    
            // copy a new target icon if not enought icons
            if (! (i < anno_target_icons.length) ) {
                anno_target_icons[i] = target_icon_tmpl.cloneNode(true);
                anno_target_icons[i].id = "target_icon_" + i; 		
                document.getElementById("videobox").appendChild(anno_target_icons[i]);
            }
			
            var trg = src_trgs[i];

            var ticon = anno_target_icons[i];
            
			var loc = findInsertIndex(trg.t, ctime);
			
			var do_display = 'no';
			if (0 < loc & loc < trg.t.length) {
				do_display = 'normal';
			} else if (current_anno_target != null && trg.id == current_anno_target.id && trg.t.length == loc) { 
				// last pos of current anno target is display afterwards
				do_display = 'ghost';
				loc = loc - 1;
			}
			
            if (do_display != 'no') { 
				//(trg.t[0] <= ctime ) && (ctime <= trg.end_t) ) {
                //var delta_t = trg.t.map(function(x) { return x - ctime });
                //var last_neg = findLastNegIndex(delta_t);

				//console.log(trg);
				//console.log(vplayer.offsetWidth + " " +trg.rel_width);
				
				var ticon_width = vplayer.offsetWidth * trg.rel_width;
				var ticon_height = vplayer.offsetWidth * trg.rel_width;
						
				console.log(ticon_width + " - " + ticon_height);
				
				var videoCoords = rel2Client(vplayer, trg.x[loc], trg.y[loc]);
                var centering = [ticon_width / 2.0, 
                                 ticon_height / 2.0];
                
                ticon.style.left = videoCoords[0] - centering[0];
                ticon.style.top = videoCoords[1] - centering[1];
				ticon.style.width = ticon_width + "px";
				ticon.style.height = ticon_height + "px";

                // If it is the current, use another color
                if (current_anno_target != null && trg.id == current_anno_target.id) {
                    ticon.style.background = "red";
                } else {
                    ticon.style.background = "blue";
                }

				if (trg.target_type == 'occlusion') {
					ticon.style.borderRadius = "0%";
				} else {
					ticon.style.borderRadius = "50%";
				}

				if (do_display == 'ghost') {
					ticon.style.opacity = 0.2;
				} else {
					ticon.style.opacity = 0.5;
				}
				
				
				ticon.style.display = "block";

            } else { // make it hide if not currently visible
                ticon.style.display = "none";
            }
        }
        
		// clear spurious anno target icons
		for (var i=src_trgs.length; i<anno_target_icons.length; i++) {
			console.log(src_trgs.length, anno_target_icons.length, i, anno_target_icons[i].id);
			document.getElementById("videobox").removeChild(anno_target_icons[i]);
		}
		anno_target_icons = anno_target_icons.splice(0, src_trgs.length);
		
    }


    function updateTargetList() {
        var vplayer = document.getElementById("videoplayer")
        var src_trgs = anno_targets; // getSourceTargets(vplayer.src, targets);
        
        var html = "";
        
        html += '<p>';
        for (var j=0; j<src_trgs.length; j++) {
            html += '<button onclick="selectTarget('+ j +'); updateTargetList();">'+ j + '</button>'; 
        }
        html += '<button onclick="createTarget(); updateTargetList();">+</button>'; 

        html += '</p>';
        for (var j=0; j<src_trgs.length; j++) {        
            if (current_anno_target != null && current_anno_target.id == src_trgs[j].id) {
                var trg = current_anno_target;
               
                html += '<p>';
                html += 'Current target: ' + j + '<button onclick="delAnnoTarget('+ j +'); updateTargetList();">X</button>';
                html += '</p>';
                
                html +='Circle width: <input size="5" id="target_rel_width" type="text" value="'+ trg.rel_width +'" onchange="updateCurrentAnnoTarget();"/><br />'
				
				var select_ru = "";
				var select_occ = "";
				
				
				function isSelected() {
					switch (current_anno_target.target_type) {
						case 'occlusion':
							return 'selected';
							break;
						case 'road_user':
							return 'selected';
							break;
						case 'nothing':
							return 'selected';
							break;
						case 'other':
							return 'selected';
							break;
						case 'pedestrian':
							return 'selected';
							break;
						case 'car':
							return 'selected';
							break;
						case 'bicycle':
							return 'selected';
							break;
						default:
							return '';
					}
				}
				
				
				html +='<select id="target_type" onchange="updateCurrentAnnoTarget();">';
				html +='<option value="roaduser" '+ isSelected() + ' >TK</option>';
				html +='<option value="occlusion" '+ isSelected() + ' >NE</option>';

			    html +='<option value="nothing" '+ isSelected() + ' >Tyhjä</option>';
				html +='<option value="other" '+ isSelected() + ' >Muu</option>';
				html +='<option value="pedestrian" '+ isSelected() + ' >-- Jk</option>';
				html +='<option value="bicycle" '+ isSelected() + ' >-- Pp</option>';
				html +='<option value="car" '+ isSelected() + ' >-- Au</option>';
				
				html +='</select>';
				
				html += "<p>List of target points:</p>"
                html += "<table>";
            
                // Show points
                for (var i=0; i<trg.t.length; i++) {  
                
                    var t = trg.t[i].toPrecision(3);
                    var x =  trg.x[i].toPrecision(3);
                    var y = trg.y[i].toPrecision(3);
                    //var end_t = trg.end_t.toPrecision(3);
                    var line = "".concat("<tr><td>",
                                            (i+1) +'. <button onclick="seekVideo('+t+', false)">'+t+'</button>',
                                            "</td><td>",
                                            x,
                                            "</td><td>",
                                            y,
                                            "</td><td>",
                                            '<button onclick="delTargetPoint(anno_targets[' + j +'],'+ i +'); updateTargetList();">X</button>',
                                            "</td></tr>");
                    html += line;
                }
                    
                // Show end
                /* if ((end_t == undefined) ) {
                    html += ""
						//'<tr><td>End: Infinity</td><td colspan="3"></td></tr>'
                } else {
                    html += '<tr><td>';
                    html += 'E <button onclick="seekVideo('+end_t+', false)">'+end_t+'</button>';
                    html += '</td><td colspan="2"><button onclick="endTarget()">End target (e)</button></td>';
                    html += '<td>';
                    html +='<button onclick="delTargetEnd(anno_targets['+ j +']); updateTargetList();">X</button>';
                    html +='</td></tr>';
                }
				*/
                html += "</table>"
            }
        }
        
        var targetlist = document.getElementById("targetlist");
        targetlist.innerHTML = html;
    }
    
    function updateVideoPosition() {
        var vplayer = document.getElementById("videoplayer");
        var vpos = document.getElementById("videoposition");
        
        var posval = vplayer.currentTime.toPrecision(3);
        console.log('rai' + posval);
        vpos.value = posval;
    }
    
    function endTarget() { // obsolate
        var vplayer = document.getElementById("videoplayer");
        current_anno_target.end_t = vplayer.currentTime;
        

        saveAnnoTargets();

        updateTargetList();        
        //updateClipList();
    }
    
    function pauseVideo() {
        var vplayer = document.getElementById("videoplayer");
        vplayer.pause();
    }
    
    function playPauseVideo() {
        var vplayer = document.getElementById("videoplayer");
        if (!vplayer.paused) {
            vplayer.pause();
        } else {
            vplayer.play();
        }
    }
    
    function playVideo(rate) {
        //console.log("playVideo " + rate)
        var vplayer = document.getElementById("videoplayer");
        vplayer.playbackRate = rate;
        vplayer.play();
        
    }


    function saveAnnoTargets() {
        /*  
            Sets the currently open anno targets to the right place
            to the all_targets, and then the all_targets is jsoned to the localStorage.
        */
		
		
        var src = document.getElementById("videoplayer").src;
        var clipname = src.split("/").pop();

        var all_targets = loadLocalTargets();
        
        if (! all_targets.hasOwnProperty(clipname)) { 
            all_targets[clipname] = [];
        }
        //console.log(typeof targets);
        all_targets[clipname] = anno_targets;
        
        saveLocalTargets(all_targets);
    }
    
    /*function scaleCurrentAnnoTarget() {
        var target_rel_width = parseFloat(document.getElementById("target_rel_width").value);
		current_anno_ctarget.rel_width = target_rel_width;
		//console.log("target_rel_width: " + current_anno_target.rel_width);
	zs
		saveAnnoTargets();
    }*/
    
	function updateCurrentAnnoTarget() {
		console.log("updateCurrentAnnoTarget called");ss
	 
		var target_type = document.getElementById("target_type").value;
		current_anno_target.target_type = target_type;
		
		
		var target_rel_width = parseFloat(document.getElementById("target_rel_width").value);
		current_anno_target.rel_width = target_rel_width;
		
		//current_anno_target.end_t = current_anno_target.t[current_anno_target.t.length-1]; // must get rid of end_t!! 2014-11-05
		
		saveAnnoTargets();
	}

	
    function seekVideo(time, relative) {
       var vplayer = document.getElementById("videoplayer");
       if (relative) { // time is relative to the currentTime
            vplayer.currentTime = vplayer.currentTime + time;
       } else {
            vplayer.currentTime = time;
       }
    }
    
    $(document).ready(function(){	
           
        // Events
        // When video is playing or seeked, update the target icons
        var vplayer = document.getElementById("videoplayer");
        
        vplayer.addEventListener("playing", function() {
            if (update_target_icon_interval_id == null) { // do not make duplicates
                update_target_icon_interval_id = setInterval( function(){ 
                    updateTargetIcon();
                    updateVideoPosition();
                }, update_target_icon_interval); 
            }
        });
        
        vplayer.addEventListener("pause", function() {
            clearInterval(update_target_icon_interval_id);
            update_target_icon_interval_id = null;
            updateVideoPosition();
			
			// save the anno targets when video pauses
			// we want to avoid saving during the video presentation/clicking, because it
			// saving may take some time and create conflicts
			saveAnnoTargets();
        });
                
                
        vplayer.addEventListener("seeked", function() { 
            updateTargetIcon();
            updateVideoPosition();
        });

        vplayer.addEventListener("canplay", function() { updateTargetList() });
 
        var videosrc = document.getElementById("videosrc");
        videosrc.addEventListener("change", function() {
            loadVideo(videosrc.value);   
            
			
            updateTargetList();
            updateTargetIcon();
        });

        var vpos = document.getElementById("videoposition");
        vpos.addEventListener("change", function() {
            var newpos = parseFloat(vpos.value);
            seekVideo(newpos, false);
        });


        /*var aclips = document.getElementById("annotated_clips");
        aclips.addEventListener("change", function() {
            //console.log(aclips.value);
            loadVideo(aclips.value);  
            //updateTargetList();
            //updateClipList();
        });
		*/
        
        // Keypresses
        $(document).keypress(function(event){	
            //console.log("rairairai" + event.which + " " + "2".charCodeAt(0))
            switch (event.which) {
                case "a".charCodeAt(0):
                    seekVideo(-0.5, true);
                    break;
                case "s".charCodeAt(0):
                    playPauseVideo()
                    break;
                case  "d".charCodeAt(0):
                    seekVideo(0.5, true);
                    break;
                case "e".charCodeAt(0):
                    endTarget()
                    break;
                case "z".charCodeAt(0): 
                    playVideo(1);
                    break;
                case "x".charCodeAt(0): 
                    playVideo(1/2);
                    break;
                case "c".charCodeAt(0):
                    playVideo(1/4);
                    break;
            }   
        });
		
		window.onbeforeunload = function(e) {
			console.log("beforeunload: saving anno targets");
			saveAnnoTargets(); // save possible changes if user is reloading the page while video is still playing...
		};
       
        
    });
    
    
    
    </script>
</head>

<body>

<div>
	Path: <input id="clippath" type="text" size=20 value="../clips/" />
    File: <input id="videosrc" type="file"/>

    <!-- <select id="annotated_clips" name="annotated_clips">
    </select> -->
</div>


<div id="annobox">
	<div id="targetlist"></div>

	<div id="videobox">
	
	
		<video id="videoplayer"
			   onclick="shotClicked(event)"		   
			   src="">
		</video>
		
		<div id="videocontrols">    
			Video position: <input id="videoposition" type="text" />
			<br />
			
			<button onclick="playPauseVideo()">Play/Pause (s)</button>
			<button onclick="playVideo(1.0)">&#9658; 1/1 (z)</button>
			<button onclick="playVideo(0.5)">&#9658; 1/2 (x)</button>
			<button onclick="playVideo(0.5)">&#9658; 1/4 (c)</button>
			
			
			<br />
			<button onclick="seekVideo(-10, true)">-10s</button>
			<button onclick="seekVideo(-0.5, true)">-500ms (a)</button>
			<button onclick="seekVideo(0.5, true)">500ms (d)</button>
			<button onclick="seekVideo(10, true)">10s</button>
			
			
		</div>
	</div>
	
</div>


<div class="target_icon" id="target_icon_tmpl" onclick="shotClicked(event)">
</div>







</body>
</html>